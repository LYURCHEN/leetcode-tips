### 题目描述：   
一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步，试图达到网格的右下角。   
问总共有多少条不同的路径？    

### 实例1：   
> 输入：m = 3, n = 2   
> 输出：3   
* 解释：    
从左上角开始，总共有 3 条路径可以到达右下角。  
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

### 解答: 
1、假设一共有m行n列，实际上从左上到右下角一共需要走的有效步数总和为m+n-2，其中向右应走n-1格，向下应走m-1格，只需要计算从m+n-2的次移动中选择m-1次向下移动（或n-1次向右移动）的方案数即可。   
即计算组合数C(m+n-2,m-1)即可。
```java
class Solution {
    public int uniquePaths(int m, int n) {//用数学中的组合数。计算C(m+n-2,m-1)。
        long res=1;
        for(int i=1,j=n;i<=(m-1);i++,j++){
            res=res*j/i; //如果写res*=(j/i)，则计算1*(2/1)*(3/2)就会计算为2,也就是必须把分子乘积算完后才能相除
        }
        return (int)res;
    }
}
```
* 时间复杂度为O(m),空间复杂度为O(1)    

2、动态规划   
用array[i][j]表示从左上角走到(i,j)的路径数量，其中0<=i<m,0<=j<n,由于我们每一步只能从向下或者向右移动一步，因此要想走到(i,j)，如果向下走一步，那么会从 (i-1, j)走过来；如果向右走一步，那么会从(i,j−1) 走过来。    
因此我们可以写出动态规划转移方程：     **f(i,j)=f(i−1,j)+f(i,j−1)**
```java
class Solution {
    public int uniquePaths(int m, int n) {//用动态规划
        int[][] array=new int[m][n];//array[i][j]表示从左上角走到(i,j)的路径数
        int i=0,j=0;
        for(;j<n;j++){ //把边界都置为1
            array[i][j]=1;
        }
        for(j=0;i<m;i++){
            array[i][j]=1;
        }

        for(i=1;i<m;i++){
            for(j=1;j<n;j++){
                array[i][j]=array[i-1][j]+array[i][j-1];
            }
        }
        return array[m-1][n-1];
    }
}
```
* 时间复杂度和空间复杂度都为O(mn)。


