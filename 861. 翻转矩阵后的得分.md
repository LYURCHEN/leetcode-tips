### 题目描述：    
有一个二维矩阵 A 其中每个元素的值为 0 或 1 。    
移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。    
在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。     
要求： 返回尽可能高的分数。    
 
### 示例：   
> 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]    
> 输出：39    

·解释：   
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]    
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39    
### 提示：   
1 <= A.length <= 20   
1 <= A[0].length <= 20   
A[i][j] 是 0 或 1

### 解答：   
#### 思路分析：如何让矩阵得分最高？（贪心）       
首先，根据题目，一个矩阵有多种变换方式，且每种方式的步骤如果交换顺序，并不影响结果，所以只关心最终变换的结果而不关心变换过程，因此，我们**总可以**先考虑所有的行翻转，再考虑所有的列翻转。      
不难发现一点：为了得到最高的分数，矩阵的每一行的最左边的数都必须为1。于是先遍历每一行，把每行最左边的数不为1的那些行进行翻转，而其他的行则保持不动。这样得到矩阵的第一列数字都为1。        
当将每一行的最左边的数都变为1之后，为了不破坏刚才翻转后的结构，就只能进行列翻转了。为了使得总得分最大，我们要让每个列中1的数目尽可能多。    
因此，开始遍历每一列，如果该列0的数目多于1的数目，就翻转该列，其他的列则保持不变。    
#### 计算得分（每一行形成的二进制数）：    
在遍历每一列的时候，其实不必真的翻转，可以直接计算得分。   
假设一共有n列（即n位的二进制数），对于第j列（此处规定最左边的列是第0列）而言，我们统计这一列0,1的数量，令其中的最大值为count，则count是列翻转后的1的数量，该列的总贡献为k*2^(n-j-1)。   

#### 代码：   
```java
class Solution {//贪心
    public int matrixScore(int[][] A) {
        int m=A.length;
        int n=A[0].length;//假设二维矩阵A有m行n列

        int i,j;
        int res=0;

        for(i=0;i<m;i++){//遍历每行第一个数，即对第一列进行处理
            if(A[i][0]==0){//如果每排第一个数为0，则转换该行
                for(j=0;j<n;j++){
                    A[i][j]^=1;//1和0与1异或就是取反
                }
            }
        }
        for(j=0;j<n;j++){//遍历每一列，统计该列含1数量，与此同时计算得分。第j列的一个1表示在res上加2^(n-j-1),如果第j列有count个1，就表示在res上加count*2^(n-j-1)。这样就加完一列所带来的得分，可以计算下一列了。
            int count1=0;//记录每一列1的数量
            for(i=0;i<m;i++){
                if(A[i][j]==1)
                    count1++;
            }
            int count=count1;
            if(count*2<m){//如果第j列1的数量少于行数的一半，即0数量比1多，就转换该列,即转换后1的数量变为m-count1
               count=m-count1;
            }
            res+=count*1<<(n-j-1);
        }
        return res;
    }
}
```
### 复杂度分析:   
* 时间复杂度：O(mn)，其中m为矩阵行数，n为矩阵列数。   
* 空间复杂度：O(1)。
