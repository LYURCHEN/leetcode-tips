### 题目描述：    
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。       
一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。      
例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

### 示例 1：     
输入：m = 2, n = 3, k = 1       
输出：3
    
### 示例 2：    
输入：m = 3, n = 1, k = 0    
输出：1


### 提示：       
* 1 <= n,m <= 100
* 0 <= k <= 20

### 分析：    
1. 用dfs，就是对每个方格的上下左右四个方位进行深度优先遍历，当遇到超出矩阵范围（横坐标小于零或>=m，纵坐标小于零或>=n）、方格坐标数位之和>k、之前已遇到过即已经算过格子数了。
就要返回0，回溯，表示此路不通。    
2. 若没有返回0，则标记当前格子为true表示已访问过   
3. 继续向四个方向遍历，返回每个方向的可达格子数之和再+1。  
4. 一种简化：由于满足数位和条件的解可以构成直角三角形，可将对四个方向的遍历改为只向下和向右。    

### 解答：   
```java
class Solution {
    int m,n,k;
    boolean[][] visited;//在movingCount中会对他们赋值,既然是全局变量，就无需作为递归参数
    public int movingCount(int m, int n, int k) {
        this.m=m;this.n=n;this.k=k;
        visited=new boolean[m][n];
        return dfs(0,0);
    }
    private int dfs(int i,int j){
        if(i<0||i>=m||j<0||j>=n||visited[i][j]==true||i%10+i/10%10+j%10+j/10%10>k)
            return 0;//此路不通，回溯
        visited[i][j]=true;
        return dfs(i-1,j)+dfs(i,j-1)+dfs(i,j+1)+dfs(i+1,j)+1;
        
    }
}
```
### 复杂度分析：    
时间空间复杂度都为O(MN)    


