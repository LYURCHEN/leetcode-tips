### 题目描述：   
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。   
* 注意:   
1.可以认为区间的终点总是大于它的起点。   
2.区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

### 示例 1: 
**输入:** [ [1,2], [2,3], [3,4], [1,3] ]     
**输出:** 1     
解释: 移除 [1,3] 后，剩下的区间没有重叠。
### 示例 2:     
**输入:** [ [1,2], [1,2], [1,2] ]    
**输出:** 2    
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
### 示例 3:    
**输入:** [ [1,2], [2,3] ]   
**输出:** 0     
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

### 解答：    
假设在某一种**最优**的选择方法中，[l_k, r_k]是首个（即最左侧的）区间，那么它的左侧没有其它区间，右侧有若干个不重叠的区间。设想一下，如果此时存在一个区间 [l_j, r_j]，使得r_j < r_k,即区间j的右端点在区间k的左侧，   
那么我们将区间k替换为区间j，其与剩余右侧被选择的区间**仍然是不重叠**的。而当我们将区间k替换为区间j后，就得到了另一种**最优**的选择方法。        
我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，**首个区间就是所有可以选择的区间中右端点最小的那个区间**。      
因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。   
 
对按照右端点排好序的区间进行遍历，并且实时维护上一个选择区间的右端点right。如果当前遍历到的区间 [l_i, r_i]与上一个区间不重合，即 l_i≥right，那么我们就可以贪心地选择这个区间，并将right 更新为r_i。
```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                if(a[1]>b[1])
                    return 1;
                else if(a[1]<b[1])
                    return -1;
                else return 0;
            }
        });
        int count=1;
        if(intervals.length==0) return 0;
        int right=intervals[0][1];//最小的右区间
        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0]>=right){
                count++;
                right=intervals[i][1];
            }
        }
        
        return intervals.length-count;
    }
}
```
### 复杂度分析:    
* 时间复杂度：O(nlogn)，其中n是区间的数量。我们需要O(nlogn) 的时间对所有的区间按照左端点进行升序排序，并且需要O(n)的时间进行遍历。因此总时间复杂度为O(nlogn)。    
* 空间复杂度：O(logn)，即为排序需要使用的栈空间。
